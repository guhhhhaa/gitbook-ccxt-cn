# websocket-support



## WebSocket支持

流WebSocket API当前正在开发中（正在进行中）。以下是在ccxt库中支持WebSocket的关键设计注意事项。

通常，并非所有交易所都提供WebSocket，但其中许多都提供。交易所的WebSocket API可以分为两类：

* _子_或_订阅_仅允许接收
* _pub_或_publish_允许发送和接收

## 子 <a id="sub"></a>

一个_子_接口通常允许订阅数据流，并监听其收入。确实支持WebSocket的大多数交换将仅提供API 的_子_类型。该_子_类型包括流媒体公开的市场数据。有时交换还允许订阅私人用户数据。用户订阅任何数据馈送后，通道将有效地开始单向工作，并不断从交换机向用户发送更新。

* 常见的公开市场数据流类型：
  * 订单簿（最常见）-已添加，已编辑和已删除订单的更新（又称_更改增量_）
  * 代码-24小时统计数据发生变化时更新
  * 填充提要（也很常见）-实时进行的公共交易
  * 交流聊天
* 私人用户数据流的较不常见类型：
  * 用户交易流
  * 余额更新
  * 自定义流
  * 特定交易流和其他流

## 酒馆 <a id="pub"></a>

一个_酒馆_接口通常允许用户发送往服务器的数据请求。这通常包括常见的用户操作，例如：

* 下订单和取消订单
* 提出提款要求
* 发布聊天消息
* 等等

**大多数交易所不提供**_**pub**_ **WS API，它们仅提供**_**sub**_ **WS API。**但是，有些交换具有完整的WebSocket API。

## 统一的WS API <a id="unified-ws-api"></a>

在大多数情况下，仅使用WebSocket API的用户将无法有效操作。交易所将流公开市场数据_sub_，而_pub_部分（缺少该部分）仍需要REST API 。

ccxt的目标是在一个统一的接口中无缝组合所有可用的网络类型，而可能不会引入向后不兼容的更改。

ccxt中的WebSocket API包含以下内容：

* 拉（按需）接口
* 推送（基于通知）界面

该_拉_的WebSocket接口复制异步REST接口一个对一个。因此，为了从切换到，用户只需要向构造函数参数提交{ws：true}选项。从那里，对统一API的任何调用都将切换到WebSockets（如果可用）（交易所支持）。`RESTpull WebSocket + REST`

该_拉_接口装置用户通过调用其方法拉动从库中的数据，而该数据被取出，并在背景合并。例如，当用户调用该方法时，将发生以下事件序列：`fetchOrderBook (symbol, params)`

1. 如果用户已经预订了该特定交易品种的订单簿更新提要，则返回的值将表示该订单簿在内存中的当前状态，以及直到调用时的所有更新。
2. 如果用户尚未订购该代码的订单簿更新，则库将在首次调用时为其订阅该订单。
3. 订阅后，图书馆将收到当前订单的快照。这将立即返回给呼叫者。
4. 它将继续及时从交易所接收部分更新，将所有更新与内存中的订单合并。每个传入的更新称为_增量_。增量表示对订单的更改（添加，编辑或删除的订单），这些更改必须在订单的最后一个已知快照之上合并。一旦交换机发送这些更新增量，它们就会连续不断地传入。
5. ccxt库在后台将增量合并到订单簿。
6. 如果用户再次调用相同的方法，则库将返回合并了所有当前增量的最新订单簿（此时返回步骤1）。`fetchOrderBook`

对于可以从Exchange WebSocket获取数据馈送的所有方法，以上行为都是相同的。如果交换不提供此类数据流，则该库将回退到HTTP REST并发送HTTP请求。

相关的统一API方法的列表为：

* fetchOrderBook
* fetchOrderBooks
* fetchTicker
* fetchTickers
* fetchTrades
* fetchBalances
* fetchOrders
* fetchOpenOrders
* fetchClosedOrders
* fetchMyTrades
* fetchTransactions
* fetchDeposits
* fetchWithdrawals

该_推送_接口包含上述所有方法，但在反向工程，图书馆推动更新给用户。这可以通过两种方式完成：

* 回调（JS，Python 2和3，PHP）
* 异步生成器（JS，Python 3.5+）

异步生成器是读取和写入数据流的首选现代方式。它们使用语言本身内置的自然得多的语法来进行回调工作。回调是反向流控制的机制。另一方面，异步发生器是直接流控制的机制。异步生成器使代码在开发和生产中更加清晰，有时甚至更快。

该_推_的情况，而不是使用回调的过时的原则，本库使用的异步发电机库理念这与直接流量控制异步发电机来完成。

，通过调用相应的用户方法。就以上示例而言，_推送_方案是以下事件序列：

1. 用户致电。`fetchOrderBook()`
2. 如果该用户尚未订阅，则的调用将使该用户订阅该供稿。`fetchOrderBook`
3. 如果用户已经订阅，则呼叫将在下一个传入更新时返回。
4. 每当有更新
5. 每当有相关的更新时，都会调用用户方法

